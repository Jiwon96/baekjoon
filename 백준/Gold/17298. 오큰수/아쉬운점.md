# 풀고자 하는바

수열 Ai의 오큰수 수열을 구하자

# 제약조건

O(NlogN) 으로 구해야됨

# 생각흐름

1. 직관적으로 θ(N^2)으로 쉽게 풀리는 것을 알 수 있다.

```cpp
for(i<N)
	for(j=i+1 < N)
		if(A[i] < A[j]) {
				ret[i] = A[j] 
				break;
}
```

위와 같은 코드는 제약조건으로 인해 시간초과가 남을 알 수 있다.

따라서 이를 최적화 해야한다.

1. 이 문제를 다시 해석하면 오른쪽에 연속으로 나오는 작은 수가 몇개있는지를 물어보는것이다.  위와 같은 값을 저장하는 배열을 arr라고 할 때 arr[i] ≥ arr[i+1]이다. ?
2. 아래 생각할 점을 참고했을 때 스택을 이용하면 위 문제를 쉽게 구현할 수 있다는 것을 깨달았고, 아래의 9와 같은 특이점을 고려했을 때 구간을 자르는 아이디어를 생각할 수 있었다. 그리고 구간을 어떻게 자를지는 스택을 이용하기로 했다. 그리고 구간에서 어떻게 접근해야 할 지를 생각해 볼 때 아래 코드2와 같다.

```
4
9 5 4 8

solution)
-1 8 8 -1
```

코드2

```cpp
for (int i = 0; i < (N - 1); i++)
	{
		while (!S.empty()&& A[S.top()] < A[i + 1]) {
			ret[S.top()] = A[i + 1];
			S.pop();
		}
		ret[i + 1] = ( - 1);
		S.push(i + 1);
	}
```

# 생각할 점.

유형별  풀이에서 스택에서 풀었으므로 스택을 사용하면 쉽게 생각할 수 있다는 것을 알고 있었다. 하지만 왜 스택인가 하는데 의문이 있다.

# 아쉬운 점

코드2를 생각할 때 구간을 한 번에 구해야 한다고 생각했다. 하지만, 구간은 점들의 집합이므로 한 지점을 어떻게 처리해야 할 지를 연속하는 방법으로 처리해야 한다.
