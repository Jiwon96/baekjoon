# 큰 풀이방법

문자열에서 문자를 탐색한다.

문자가 있으면 제거후 다시 탐색한다.

여기서 중요한 점은 탐색과 제거이다. 탐색과 제거를 시간이 적게 드는 방향으로 해야한다.

# 내가 틀린 이유

1. str.find()는 O(n), 이기 때문에 replace와 같이 쓰면 O(N^2)이 되므로 다른 방법을 써야한다.
2. 1과 같은 이유로 입력이 됨과 동시에 문자열을 교체 해야된다.

# 공부해야 할 점.

string method (find, replace, erase  등)

여기서 많이 쓰이는 방법은: 다음과 같은 방법이다.

아래와 같은 방법은 t라는 임시 문자열을 넣고, 이 글자에 하나씩 넣어준다. 이 때 내가 검색해야할 단어보다 글자가 커지면 그 때부터 지워야할 길이만큼 이전길이부터 탐색해 특정 문자열이 들어있는지 확인한다.

특정 문자열은 최대 30글자이기 때문에 상수 or logN 보다 살짝 큰 수이다

```cpp
for (int i = 0; i < str.length(); i++)
	{
		t += str[i];
		if (t.length() >= b_len) {
			bool flag = true;
			for (int j = 0; j < b_len; j++) {
				if (word[j] != t[t.length() - b_len + j]) {
					flag = false;
					break;
				}
			}
			if (flag) {
				t.erase(t.end() - b_len, t.end());
			}
		}
		
	}
```

# 복습단계에서 깨달은 점
스택의 정의는 FILO임. 이를 리스트로 구현하든 배열로 구현하든 FILO만 만족하면 스택이라고 정의할 수 있는 것임. (추측인데 스택의 특징은 입력의 반대방향으로 processing이 일어난다는 것이다)
여기서 문제의 힌트는
1. 남는 문자열을 순서대로 이어 붙인다. -> 남는 문자열-> 문자열을 processing 해야됨 | 이어 붙인다 -> 이어 붙이는 함수가 있어야 한다. 
2. 새로 생긴 문자열에 폭발 문자열이 포함되어 있을 수 있다. -> 이 말은 문자열에 변화가 생기면 탐색을 다시 진행해야 한다는 의미이다.
3. 제약조건에서 입력이 1000000이므로 이보다 조건에서 한층 자유로운 theta(N^2)으로 풀이를 생각했을 때 완전탐색을 하면 풀릴 수 있다고 짐작된다. 하지만, 이는 시간초과이므로 theta(N)에서 이를 처리해야 한다. 2를 참고하면 문자열에 변화가 생기면 탐색을 다시 진행해야 한다는 점에서 앞보단 뒤에서 탐색을 해야한다.(왜냐하면 우리는 입력되자마자 탐색을 진행할 것인데 i-1에서는 폭발이 일어나지 않았다고 가정해야 하므로, 변화는 뒤에서 생김) -> 뒤로 일어난 변화로 인해 입력의 반대 방향으로 processing이 일어난다. -> 스택 구조가 적합하다고 생각한다.
