# 접근 방법
1. 그래프 문제인지 파악하는게 매우 중요하다.<br>
2. 1234는 4가지 경우의 숫자와 관계를 맺고 있으므로 그래프 문제라고 생각할 수 있다.<br>
3. 이 때 BFS or DFS 중에 어떤 방법으로 풀 것인지 고려해야 하는데 예를 하나 생각해본다면 쉽게 bfs로 풀어야 하는 것을 생각할 수 있다.
  * ex) D->D->D->D->D 이런식으로 계속 파고 드는게 옳게 접근하는 것인가? NO 그러면 BFS라고 생각한 것이다.
  * 어느 방법으로 가야할지 확신을 갖긴 어렵지만, 어느 방법이 틀렸다고 생각하는 것은 쉽다.
4. top-down, bottop-up 중에 bottom-up으로 가는게 편하다.
* 이유: for문으로 구현할 수 있기 때문에(bfs는 bottom-up과 잘 어울림)<br>
* 더 엄밀하게 말하면 부모 모드에서 자식 노드로 가면서 문제를 해결하기 때문이다.(작은 문제에서 해결하면서 큰 문제로 감)<br>

# 풀이 방법
1. 숨박꼭질4와 비슷하게 풀면 되는데, -1을 MOD 연산하면 -1이 나오더라<br>
2. vector <> a[10]을 clear하기 위해선 a[i]마다 하나씩 clear 해줘야됨<br>
3. 숫자를 변환해주는 translate 함수, bfs 함수를 구현하면 됨

# 메모리 초과
1. 어디에서 무한 루프가 걸리고 있다는 것을 의심해보기<br>
2. 무엇을 곱하든 0을 만드는 0, 0-1 =-1으로 인덱스 에러를 만드는 0은 항상 조심해야 한다.<br>

# 주의할 점
1. code에서 visited[next]=true를 하지만, 이는 bfs가 노드에서 노드까지의 까지의 최단 거리를 보장한다.
2. <b>다익스트라는 한 노드에서의 최소 거리</b>를 구하는 것인데, <br>
예를 들어 i가 출발점이라 하자. 그러면 BFS 가 O(VlogE)이므로 각 노드마다 하기 위해선 O(V^2logE)가 걸린다.
3. 하지만 이를 pq와 bfs를 이용하면 O(VlogE)로 구할 수 있다. 경로가 ABCDE를 통해 각 노드마다 구할 수 있다면
4. AB에서 최단거리가 주어져 있을 테니
5. AB의 최단 거리 BC의 최단 거리를 구하면 되는데 이 때 A에서 다른 노드로 너비 탐색을 하는게 아니라 B에서 너비 탐색을 진행하면 된다. 이 때 조건은
6. A부터 다른 간선까지의 거리가 A,B 간선의 길이보다 길면 B에서 탐색을 먼저 하는 아이디어이다.

즉. 간선마다 중요도를 둬 너비 탐색을 하는 노드를 우선순위를 부과하면 된다.<br>
만약 A-C 노드보다 A-B-C노드가 길이가 짧다면 AB간선을 넣고 B에서 다시 너비 탐색을 하면 된다.<br>
간선의 중복 탐색을 피하기 위해서 visited를 사용하므로<br>
<b>다익스트라에서는 부모에 따라 자식 노드가 같은 우선순위가 아니므로</b><br>
해당 간선이 탐색을 완료했을 때 <b>즉 해당 노드가 처음 들어왔을 때 true</b>를 해야한다.<br>
하지만 <b>일반 bfs에서는 간선의 중요도가 없으므로같은 부모에서는 우선순위가 같다</b>고 여겨지기 때문에 visited를 next에 해도 괜찮았다.<br하지
이 부분이 가장 큰 주의점이다.
