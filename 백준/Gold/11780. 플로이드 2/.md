# 공부할 것 (못품)
[플로이드 와샬](https://chanhuiseok.github.io/posts/algo-50/)<br>
[문제 풀이](https://yabmoons.tistory.com/441)

* 플로이드 와샬 아이디어는 만약 경로가 1->3->5->7->9 이면
* 첫 번째 k=3 일 때 1->3->5가 수정되고
* 두 번째 k=5 일 때 첫 번째에서 갱신된 정보를 이용해 1->3->5->7이 되고
* 세 번째 k=9 일 때 첫, 두번째 에서 이용된 정보board[1][7]을 이용해 1->3->5->7->9가 갱신됨
* 2차원에서 최단 경로가 존재하면 계속 삽입하는 방식(theta(n^3))으로 경로를 모두 만들어 낼 수 있음


# 아이디어
노드가 N개인 그래프에서 i->j까지 가는 최단 거리의 노드 i, j 사이의 노드는 n개에서 i, j노드를 제외한 최대 (n-2)개 이다.<br>
만약 n-2보다 크면 1,(2,3,4,5,6,7,8,........ n-1)n ()사이의 개수가 n-2개인데 그러면 어떤 노드를 두 번 지나간 것이 되므로 최단 거리이거나 최단 거리보다 큼


# 복습
* i, j까지의 최단 경로가 존재할 때 그 사이 노드를 하나씩 껴가는 알고리즘이다.
<br>

``` c++
for(int k=1; k<=노드개수; k++)
  for(int i=1; i<=노드개수; i++)
    for(int j=1; j<=노드개수; j++){
        if(board[i][j] > board[i][k]+board[k][j])
        {
          board[i][j] = board[i][k]+board[k][j];
        }
     }
```

이 때 사실 i, j가 정해져있다면 k는 i와 j를 제외해 탐색을 하면 되지만, 그래도 theta(N^3)이므로 i,j가 사이에 있는 경우도 포함해 k를 N번 돌리면 전체 노드에 대한 최단 거리가 주어진다.<
이것이 가장 큰 핵심이다.
