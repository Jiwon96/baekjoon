# 아이디어
트리이기 때문에 circulate이 없음 & 노드와 간선과의 관계임<br>
그렇다면 DFS or BFS로 경로를 탐색할 수 있음<br>

첫 번째 문제: 일단 문제는 노드의 끝을 어떻게 판단할 것인지,<br>
두 번째 문제: 트리의 지름을 어떻게 판단할 것인지<br>
가 관건임<br><br>

일단 첫 번째 문제는 flag를 하나 세워서 풀어낼 수 있음 easy~<br>
두 번째 문제가 어떻게 푸냐인데, 일단 나는 DFS로 풀어야겠다는 생각을 먼저 했음(여기서 최단 거리로 결정되는 노드 경로는 고정되어있다고 생각함)<br>
처음에 BFS로 접근했는데<br>
반례가 바로 떠올랐음 예를 들어서 저기 말단 노드에 부모밑 자식이 30, 30이 달려있고 나머지는 1이라면 트리의 지름은 30+30이 되야할 것<br>
이 때는 BFS로 판별하기 어렵겠다라는 생각을 함<br>
따라서 DFS로 접근을 했는데<br>
노드에서 다른 자식간의 모든 길이를 알아낸다음에 정렬해서(내가 생각한 반례를 해결하기 위함이고) 더하고(어차피 부모도 중간에 낀 노드:노드의 지름)<br>
부모한테는 큰 노드만 반환하면 된다고 생각했음<br>
(가장 큰 경로를 반환해야 내 부모에서 다른 자식까지 이르는 최대 지름을 얻기 때문)

DFS는 깊이 우선이기 때문에 한 곳만 판다 정책인것을 까먹지 않기(중간에 어떤 지점을 거쳐도 거기서 끝까지 판다)

# 시간 복잡도
이 때 노드가 100000개 정도니까 그래프가 안되려면 간선은 약 999999개 그렇다면 정렬을 해도 nlogn이니까 충분히 가능하다고 생각했음


thank to Jesus
지혜를 주셔서 감사합니다.
