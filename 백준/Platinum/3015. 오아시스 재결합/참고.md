아직 하나도 모르겠다. 이거보면서 복습하자
https://everenew.tistory.com/89

생각할 점2
왜 stack top을 기준으로 값을 변경할까? 이유에 대해 타당성을 부여해야됨<br>
-> 문제에서 제약조건으로 키가 크면 못본다고 했음 이 조건을 잘 생각했어야 됨<br>
<br>
<br>
# 아쉬운 점
1. 조건에 대해 어떻게 풀지 생각했어야됨<br>
2. 스택은 인터벌에 대한 관계를 표현할 수 있음. 즉 어떤 두 점간의 관계를 나타낼 수 있음<br>
  - 여기서는 top과 now에 대한 관계를 나타낸다. 따라서 부분적으로 생각했을 때 now~top까지 볼 수 있는 사람수를 구하는게 문제였음.<br>

```
for(int i<N)
{
  if(top==now 높이){
    볼 수 있는 사람은 같은 높이의 사람들
    if(스택 크기>1){
      가장 가까운 사람까지 볼 수 있음
    }
  }
  else{
    볼 수 있는 사람 한명
  }

}
```

# 개선할 점
1. 식을 만들 때 조건에 대해 고민해보자. 특히 조건은 어떤 규칙이 있을 가능성이 높은 것 같다.(여기서는 스택이 내림차순 정렬이 키워드였음) 작게 먼저 구해보자.<br>
2. 예외 조건을 생각해서 그 경우를 계산하자<br>

# 복습으로 한 점
만약 top의 height가 now의 height보다 작으면 top은 now 뒤를 보지 못한다.<br>
따라서 top에 대해서 to the bottom 방향과 to the top 방향으로 탐색할 수 있다. <br>
top 방향으로 탐색해야 한다. 왜냐하면 bottom 방향으로 탐색하면 입력이 커질수록 복잡해지기 때문이다.<br>
<br>
코드에서 이해안가는 부분이 2군대 있었다.<br>
첫 번째는 if(S.size()>1) cnt_pair++; <br>
두 번째는 else{ cnt_pair++}이다.<br>
<br>
첫 번째를 이해하기 위해선 두 번째를 이해하는게 더 수월하기 때문에<br>
두 번째를 먼저 설명하겠다.<br><br>
두 번째는 top에서는 now가 무엇이든간에 볼 수 있기 때문에 +1를 증가하는 것이다.
<br>
<br>
다시 첫 번째로 돌아가면<br>
첫 번째에서 if문을 쓰는 이유는 스택을 구성할 때<br>
우리는 감소함수처럼 스택을 구현했다.<br>
따라서 5 2 2 5 5 이렇게 되어 있으면 네 번째 5에서는<br>
스택에는 5 2 이렇게 구성된다.<br>

pair(same height)를 이용해서 두 번째 2에서 네 번째 5, 세 번째 2에서 네 번째 5를 계산할 수 있지만<br>

에러는 여기서 세 번째 2와 첫 번째 5이다.<br>
두 번째 2에서는 첫 번째 5에서 else문에서 바로 cnt++하기 때문에 +1이 되지만<br>
세 번째 2에서는 if에 들어가기 때문에 +1을 해줄 수가 없다.<br>
따라서 size>1이면 저렇게 더하기를 해줘야 한다.<br>

풀이는 오른쪽으로 갈 때 top과 now의 높이를 어떻게 프로그래밍 할지에 대해 물어보는 것이었다.
